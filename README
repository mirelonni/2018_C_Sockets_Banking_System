Am rezolvat tema multiplexand stdin, TCP_ul si UDP-ul.
Caracteristicile blocante ale transferului si ale unlock-ului sunt eliminate
printr-o succesiune de conitii si flaguri.

In implementarea temei am folosit o structura numita user, cu care am facut
un array, pe care l-am folosit sa stochez, prelucrez si cerific informatiile
despre useri.

in cadrul structurii am introdus datele oferite de voi, si am adaugat cateva
campuri destul de simplu de inteles, cel pe care consider ca trebuie sa il
explic este "state".

Campul "state" ajuta la identificarea starii in care se afla cardul:
0 - daca nu este nimeni logat pe acel card
1 - daca cineva este logat pe card
2 - daca cineva a initializat un transfer pe acel card
3 - daca cardul este blocat
4 - daca cineva a inceput deblocarea

Daca comenzile primite nu faca match pe caseurile lor(login, logout, etc.)
ajung in ultimul caz unde fie sunt ignorate fie sunt verificate, daca este
cazul, ca un raspuns la [y/n] de la transfer

Sper ca din comentariile mele din cod s-a inteles loica, le-am pus in locuri
mai greu de inteles la prima vedere, cum ar fi:

=> NOTA5 de la pagina 5(pdf) - unde nu am lasat producerea unei duble deblocari
cu ajutarul starii din struct si dupa forma mesajului care vine de la
client(mesaj de la client care este influentat de alte flaguri de conirmare
a reaspunsului serverului la o a doua comanda de unlock)

=> structura terminal care ajuta la numararea incercariilor consecutive de pe
fiecare client

=> daca odata inceput transferul se trimite o comanda care face match pe alt
case(login, logout, etc)


**make clean sterge si log-urile

Sper ca explicatiile meleau fost de ajuns si ca nu am ratat vreun caz.
Scuze de intarziere.
